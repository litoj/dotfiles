#!/usr/bin/bash

. sss

SSS_OPTS[about]='MOM - Media Operation&Manipulation
A collection of media operation/manipulation scripts.'

SCRIPT_OPTS[ffmpegLogLvl]=2
defineParams=(
	ffmpegLogLvl 'f?' "${REGEX['int']}" 'Set ffmpeg log level or +f to use the script $logLvl'
	"${defineParams[@]}")
SSS_OPTS[onNoArg]=1

ffmpegCmd() {
	local cmd=(ffmpeg -hide_banner -v)
	((SCRIPT_OPTS['ffmpegLogLvl'] > 0)) &&
		echo "${cmd[@]}" ${LOG_NAMES[${SCRIPT_OPTS['ffmpegLogLvl']}]/warn/warning} ||
		echo "${cmd[@]}" ${LOG_NAMES[$((-SCRIPT_OPTS['logLvl']))]/warn/warning}
}

jobSrcDistributor() {
	declare -i i=$1
	local src=("${src[i]}")
	export ACTION+="['${src/*\//…/}']"
	"$fn"
}

actionInfo download 'download audio/video from given url with `yt-dlp`'
downloadParams=(
	metadata 'm?' '' 'Keep metadata (default=true)' # NOTE: pipeline candidate - output as nometa src
	format 'f?' '.+' 'Yt-dl download format (default=ba[ext=webm])'
	src '$+' 'http.+' 'Urls to download'
	dst '$*' '$d$D\.(opus|m4a)' 'Output in yt-dlp format or dir (default=./%(creator)s - %(title)s.opus)')
download() { # TODO: allow video; allow qual/fmt selection through a picker
	[[ $dst && ! -d $dst ]] && local ext=${dst/*./} || local ext=opus
	local cmd=(yt-dlp -q -N 8 -f "${format:-ba[ext=${ext/opus/webm}]/ba}")
	[[ $dst ]] || local dst=.
	[[ -d $dst ]] && local tmp="%(creator)s - %(title)s" || local tmp=${dst##*/}
	local prefix=/tmp/mom-$ACTION
	declare -i i=-1 srcN=${#src[@]}

	while ((++i < srcN)); do
		src=${src[i]%%&*}
		function isolated() {
			local prefix=$prefix-${src#*=}-
			local cmd=("${cmd[@]}" "$src" -o "$prefix$tmp") dst=${dst[i]:-$dst}
			log Warn || cmd+=(-q)
			exec "${cmd[@]}" && {
				cmd=("$prefix"*)
				local file=$cmd.$ext
				((${#cmd[@]} > 1)) && log Warn " - File has been downloaded multiple times, using '$file'"
				ffprobe "$cmd" |& grep 'Audio: aac' -q && local ext=m4a || local ext=opus
				exec mv -f "$cmd" "$file"

				cmd+=("$file")
				[[ -d $dst ]] && dst="${dst%/}/$(
					sed -e 's/\(.* -\) \1/\1/' -e 's/^NA - //' -e 's/ [([].*[])]//g' \
						-e 's/\(.*\) by \(.*\)\(\.\w\+\)$/\2 - \1\3/' <<<"${file:${#prefix}}"
				)" || dst="${dst%.*}.$ext"
				if ((metadata >= 0)); then
					exec mv "$file" "$dst"
				else
					NO_CONFIG=0 call edit --delete-src --no-metadata "$file" --dst="$dst"
				fi
			}
		}
		ACTION+="['$src']" isolated
	done
}

declare MPV_PICKER_PICK_PATH='/tmp/mom-mpv-picker.pick'
mpvPicker() {
	if [[ ! -f $src ]]; then
		log Error ".$1 <mpvPicker>: \$src file must be set before picking a time"
		return 1
	fi

	if [[ ! -f $MPV_PICKER_PICK_PATH ]]; then # pick values
		local pickerFile=${MPV_PICKER_PICK_PATH%.pick}.lua
		cat >>"$pickerFile" <<lua
			require 'mp'
			
			local function divmod(a, b) return a / b, a % b end
			
			local function getTime()
				local m, remainder = divmod(mp.get_property_number 'time-pos', 60)
				local h, m = divmod(m, 60)
				local s = math.floor(remainder)
				local ms = math.floor((remainder - s) * 1000)
				return string.format('%02d:%02d:%02d.%03d', h, m, s, ms)
			end
			
			local function add(varName, value)
				local f = io.open(_G.pick_file, 'a')
				local src = mp.get_property 'path'
			
				mp.osd_message(varName .. ' = ' .. value, 2)
			
				f:write(varName)
				f:write '='
				f:write(value)
				f:write '='
				f:write(src)
				f:write '\n'
				f:close()
			end
			local function addVolume()
lua
		if [[ $volume != -* ]]; then # don't change volume if an absolute value in dB was set
			cat >>"$pickerFile" <<lua
				add('volume', mp.get_property_number 'volume' / 100)
lua
		else
			cat >>"$pickerFile" <<lua
				add('volume', '$volume')
lua
		fi
		cat >>"$pickerFile" <<lua
			end
			
			-- NOTE: maybe do dynamically from action regex defs?
			mp.add_key_binding('e', 'pickEnd', function() add('end', getTime()) end)
			mp.add_key_binding('s', 'pickStart', function() add('start', getTime()) end)
			mp.add_key_binding('f', 'pickFade', function() add('fadeout', getTime()) end)
			mp.add_key_binding('F', 'pickFadeEnd', function() add('fadeoutEnd', getTime()) end)
			mp.add_key_binding('v', 'pickVolume', addVolume)
			mp.add_key_binding('Enter', 'confirm', function()
				mp.commandv 'quit'
			end)
			mp.add_key_binding('x', 'reset', function()
				os.remove(_G.pick_file)
				mp.commandv 'quit'
			end)
	
			_G.pick_file = '${MPV_PICKER_PICK_PATH}'
lua

		local _opts=(--msg-level=cplayer=error --no-audio-display --loop-playlist --display-tags-clr
			--term-playing-msg="Playing $( ((SCRIPT_OPTS['color'] > 0)) &&
				ansi italic "'\${media-title}'" reset || echo '${media-title}')
$(print "<s> to pick --start")
$(print "<e> to pick --end")
$(print "<f> to pick --fadeout")
$(print "<Shift+F> to pick --fadeoutEnd")
$(print "<v> to pick --volume")
$(print "<Enter> to confirm and quit")" --script="$pickerFile"
		)

		while mpv "${_opts[@]}" "${src[@]}"; do
			[[ -f $MPV_PICKER_PICK_PATH ]] && break
			echo 'You must use the keybindings to set the values'
		done

		rm "$pickerFile"
		[[ ! -f $MPV_PICKER_PICK_PATH ]] && return 1
	fi

	DEFAULT_VALUE=${!1:-${DEFAULT_VALUE:-0}}
	declare -n arr=$1

	local line var
	declare -A fileMappings
	while read -r line; do # filter values for variable in question ($1)
		var=${line%%=*}
		[[ $var == "$1" ]] || continue
		line=${line#*=}

		fileMappings["${line#*=}"]=${line%%=*}
	done <"$MPV_PICKER_PICK_PATH"

	arr=()
	for line in "${src[@]}"; do
		arr+=("${fileMappings["$line"]:-$DEFAULT_VALUE}")
	done
	declare +n arr
}
mpvVolumePicker() {
	DEFAULT_VALUE=1 mpvPicker "$@"
}
timeToSeconds() {
	local str=${1#0}
	declare -i s=0
	while [[ $str == *:* ]]; do
		((s = s * 60 + ${str/:*/}))
		str=${str#*:}
		str=${str#0}
	done
	((s = s * 60 + ${str%.*}))
	if [[ $str == *.* ]]; then
		echo "$s.${str#*.}"
	else
		echo $s
	fi
}
secondsToTime() {
	[[ $1 == *.* ]] && local str=.${1#*.} || local str
	declare -i s=${1%.*}
	str=$((s % 60))$str
	while ((0 < (s = s / 60))); do
		str=$((s % 60)):$str
	done
	echo "$str"
}

# expects $src, $dst in form $d.ext or $F
# determine $out, $ext
# NOTE: this overwrites caller → relies on use inside runJob() or just a one-time use
determineOut() {
	if matcher='$D[^/]\.[^ ]+' argMatch "${dst:=.}"; then # file $dst has priority
		ext=${dst##*.}
		out=$dst
		return
	elif [[ -d $dst ]]; then # for directory dst use src as the name
		dst=${dst%/}
		[[ $ext ]] || ext=${src##*.}
	elif [[ $dst == *.* ]]; then # use the name but dst for dir and ext
		ext=${dst##*.}
		[[ $dst == */* ]] && dst=${dst%/.*} || dst=.
	else
		log Error ".dst: unexpected value format '$dst'"
	fi
	mkdir -p $dst
	out=${dst}/${src##*/}
	out=${out%.*}.$ext
	if ((rename > 0)); then
		out=$(NO_CONFIG=0 call rename --print-only "$src" "$dst/.$ext")
	fi
}

# strip PWD from given variable
# used to produce cleaner log messages + simpler path comparison
stripPWD() {
	declare -n _var=$1
	[[ $_var == ./* ]] && _var=${_var:2} || _var=${_var#"$PWD"/}
}

# expects $cmd, $deleteSrc, $src, $dst, $out
# executes $cmd with safely named $out
#   then moves $out to $src if ! $dst
runCmdWithCleanup() {
	out=$(ACTION+=.dst getFreePath "$out")
	stripPWD src
	stripPWD out
	exec "${cmd[@]}" "$out" && if ((deleteSrc > 0)); then
		local name=${src%.*}
		if [[ -z $dst && $out == "${name%_*}"_*.${src##*.} ]]; then # move if name is the same
			exec mv "$out" "$src"
		else
			exec rm "$src"
		fi
	fi
}

PICKER_FOR_REGEX[${REGEX['timestamp']}]=mpvPicker
actionInfo edit 'cut, strip metadata and/or convert media; time picker works only after `src`'
declare -A editBuilder=([volume]=mpvVolumePicker)
editParams=(
	copy 'c?' '' 'Copy, otherwise convert to opus (disables -bvfp)'
	metadata 'm?' '' 'Keep metadata (default=true)'
	rename 'r?' '' 'Rename using rename action, file $dst has priority'
	deleteSrc 'd?' '' 'Delete $src file (default=false)'
	bitrate 'b*' "${REGEX['pint']}" 'Output bitrate in kbps (default=96 for <=192kbps, else 128)'
	src '$+' "${MIME_TYPES['audio']}" 'File to cut/convert'
	start 's*' "${REGEX['timestamp']}" 'Start time (default=0)'
	fadeout 'f*' "${REGEX['timestamp']}" 'Fadeout start time, or seconds from the end'
	fadeoutPadding 'p?' '[0-9]+(\.[0-9]+)?' 'Shorten fadeout to fit this much silence (default=4)'
	fadeoutEnd 'F*' "${REGEX['timestamp']}"
	'End of fadeout, or fadeout duration, priority: -e > -F > -p'
	end 'e*' "${REGEX['timestamp']}" 'End time, or seconds from the end (default=0)'
	volume 'v*' "${REGEX['float']}(dB|LUFS)?" 'Volume multiplier or target dB (default=1)'
	volumeTolerance 't?' "${REGEX['ufloat']}" 'Required dB offset before correcting to given dB/LUFS (default=0.4)'
	pickAll 'a?' '' 'Use a picker for all timestamp values + volume - for automation'
	dst '$?' '$d$D\.(opus|mp3|m4a|flac|wma)' 'Output file/dir (default=`$src.opus`)')
edit() { # TODO: use picker only
	if matcher='$D[^/]\.[^ ]+' argMatch "$dst" && ((${#src[@]} > 1)); then
		log Error ' - cannot specify multiple $src and a file $dst'
		return 1
	fi

	if ((pickAll > 0)); then
		[[ $volume ]] || declare -a volume
		mpvVolumePicker volume || return 1

		local opt
		for opt in start fadeout fadeoutEnd end; do
			declare -a $opt
			mpvPicker $opt
		done
	fi
	rm -f "$MPV_PICKER_PICK_PATH"

	local cmd=($(ffmpegCmd) -i '' -map a)
	declare -i srcN=${#src[@]} fP=${fadeoutPadding:-4} fileArgPos=${#cmd[@]}-3
	((metadata < 0)) && cmd+=(-map_metadata -1)
	((copy > 0)) && local volume=() fadeout=() cmd+=(-c copy)

	function isolated() {
		local cmd=("${cmd[@]}")
		cmd[$fileArgPos]=$src

		if ((copy <= 0)); then
			local b=${bitrate[i]:-$bitrate}
			local srcBr=$(ffprobe "$src" |& sed -n 's#.*bitrate: \([0-9]\+\) kb/s.*#\1#p')
			if [[ -z $b ]]; then
				[[ ($src == *.opus && $srcBr -ge 118) ||
					$src =~ \.(flac|wav)$ || $srcBr -gt 220 ]] && b=128 || b=96
				log Info ".bitrate = $b"
			fi
			local cmd+=(-b:a ${b}k) cmdBitratePos=${#cmd[@]}
		fi

		local s=${start[i]}
		[[ -z $s && ${start:-:} != *:* ]] && s=$start || s=${s:-0}
		[[ $s != 0 ]] && cmd+=(-ss $s)

		local e=${end[i]} endSeconds
		[[ -z $e && ${end:-:} != *:* ]] && e=$end || e=${e:-0}
		local fade=${fadeout[i]}
		[[ -z $fade && ${fadeout:-:} != *:* ]] && fade=$fadeout || fade=${fade:-0}

		if [[ $e != 0 || $fade != 0 ]]; then
			if [[ $e == *:* ]]; then
				endSeconds=$(timeToSeconds $e)
			else
				endSeconds=$(bc <<<"$(timeToSeconds $(
					ffprobe "$src" |& sed -n 's/.*Duration: \([^,]*\),.*/\1/p'
				))-$e")
				e=$(secondsToTime $endSeconds)
			fi

			if [[ $fade != 0 ]]; then
				# NOTE: fade in seconds is calculated FROM the new --end
				[[ $fade == *:* ]] && fade=$(timeToSeconds $fade) || fade=$(bc <<<"$endSeconds-$fade")

				local fE=${fadeoutEnd[i]}
				[[ -z $fe && ${fadeoutEnd:-:} != *:* ]] && fE=$fadeoutEnd || fE=${fE:-0}

				if [[ $fE == 0 ]]; then
					fE=$(bc <<<"$endSeconds-$fade-$fP")
					[[ $fE == .* || $fE == -* ]] && log Error '.fadeoutEnd < 1s'
				else
					[[ $fE == *:* ]] && fE=$(bc <<<"$(timeToSeconds $fE)-$fade")
					[[ $fE == .* ]] && fE=0$fE

					[[ ${end[i]:-0} == 0 ]] && e=$(bc <<<"$fade+$fE+$fP")
					[[ $e == .* ]] && e=0$e
				fi

				cmd+=(-af afade=out:st=$fade:d=$fE)
			fi

			cmd+=(-to $e)
		fi

		local v=${volume[i]:-${volume:-1}}
		if [[ $v == -* ]]; then
			if [[ $v == *dB ]]; then
				v=$(
					ffmpeg -hide_banner -i "$src" -af volumedetect -f null - |&
						sed -En "s,.*mean_volume: -([0-9.]+) dB,${v%dB}+\1,p" | bc
				)
			elif [[ $v == *LUFS ]]; then
				v=$(
					ffmpeg -hide_banner -i "$src" -af loudnorm=print_format=summary -f null - |&
						sed -En "s,Input Integrated:.*-([0-9.]+) LUFS,${v%LUFS}+\1,p" | bc
				) # currently we only change measurement method, not adaptation method (loudnorm)
			else
				log Error ": Invalid --volume=$v - either dB or LUFS"
			fi

			# NOTE: always adjust the volume when already converting the filetype anyway (src!=opus)
			if [[ $v == 0 || $src == *.opus ]] && (($(bc <<<"${v#-} < ${volumeTolerance:-0.4}"))); then
				log Info ".volume = 1 (differs by ${v}dB from target)"
				v=1
			else
				v+=dB
				log Info ".volume = $v"
			fi
		fi
		if [[ $v != 1 ]]; then
			[[ $fE ]] && cmd[-3]+=,volume=$v || cmd+=(-af volume=$v)
		fi

		local out ext=opus dst=${dst}
		determineOut

		if [[ -d $dst ]]; then # dst as file overrides $rename and $copy
			if [[ $copy -eq 0 && $src == *.$ext && $v == 1 && -z $fE ]]; then
				if [[ -z $s && -z $e ]]; then
					log Warn ': no changes required -> skipping'
					return
				fi
				log Info '.copy = true (no reencoding required)'
				cmd=("${cmd[@]::cmdBitratePos-2}" -c copy "${cmd[@]:cmdBitratePos}")
				local copy=1
			fi

			((copy > 0)) && out=${out%.*}.$ext
		fi

		runCmdWithCleanup
	}
	fn=isolated runJobs jobSrcDistributor $(seq 0 $((srcN - 1)))
}

actionInfo giphie 'convert images to a looped mp4'
giphieParams=(
	src '$+' "${MIME_TYPES['image']}" 'Image files to concat into a gif-like video'
	interval 'i?' "${REGEX['ufloat']}" 'Interval in seconds between images (default=1/framerate)'
	loops 'l?' "${REGEX['pint']}" 'Number of loops (default=1)'
	duration 'd?' "${REGEX['ufloat']}" 'Duration of the video in seconds (default=i*l*#src)'
	framerate 'f?' "${REGEX['ufloat']}" 'Framerate (default=#src)'
	crf 'c?' "${REGEX['pint']}" 'CRF quantization setting (default=32)'
	dst '$?' '$d$D\.mp4' 'Output file/dir (default=`$src.mp4`)')
giphie() {
	declare -i srcN=${#src[@]}
	if [[ ($interval || $fps) && $loops && $duration ]]; then
		log Error ': only two of -i/-l/-d can be used'
		return 1
	fi
	local seqN=$((srcN)) # * 2 - 2))
	log Debug ".seqN = $seqN"

	if [[ $framerate ]]; then
		local interval=$(bc <<<"scale=3; 1 / $framerate")
		log Debug ".interval = $interval"
	fi

	if [[ $duration ]]; then
		if [[ $interval ]]; then
			local loops=$(bc <<<"scale=0; $duration / $interval / $seqN")
			log Debug ".loops = $loops"
		else
			local interval=$(bc <<<"scale=3; $duration / ${loops:-1} / $seqN")
			log Debug ".interval = $interval"
		fi
	elif [[ -z $interval ]]; then
		local framerate=${framerate:-$seqN}
		local interval=$(bc <<<"scale=3; 1 / $framerate")
	fi
	[[ $framerate ]] || {
		local framerate=$(bc <<<"scale=3; 1 / $interval")
		log Debug ".framerate = $framerate"
	}

	local cmd=($(ffmpegCmd) -framerate $framerate)

	local filterstr=""
	declare -i i=-1
	while ((++i < srcN)); do
		cmd+=(-i "${src[$i]}")
		filterstr+="[$i:v]"
	done
	((i = i - 1))
	# while ((--i > 0)); do
	# 	cmd+=(-i "${src[$i]}")
	# 	filterstr+="[$((seqN - i)):v]"
	# done
	cmd+=(
		-filter_complex "${filterstr}concat=n=$seqN:v=1:a=0"
		-r $framerate -pix_fmt yuv420p -q 0 #q=0 means lossless
	)

	local tmp="/tmp/mom-$ACTION-${src##*/}.mp4"
	exec "${cmd[@]}" "$tmp" || return 1

	exit 1
	cmd=(
		$(ffmpegCmd) -stream_loop ${loops:-1} -i "$tmp"
		-r $framerate -preset veryslow -crf ${crf:-32} -g 65536 -keyint_min 32769 -sc_threshold 0
	)

	local dst=${dst} out ext=mp4
	determineOut
	exec "${cmd[@]}" "$out" && rm "$tmp"
}

actionInfo cut 'cut and concat video files'
cutParams=(
	copy 'c?' '' 'Copy all data, no recompression (disables -qa and volume amplifier)'
	deleteSrc 'd?' '' 'Delete $src file (default=true if only one clip is created from only one src)'
	crf 'q?' "${REGEX['pint']}" 'CRF quantization setting (default=28)'
	metadata 'm?' '' 'Copy metadata from the first file (default=true)'
	rename 'r?' '' 'Rename using rename action, file $dst has priority'
	audioCodec 'A?' '[0-9a-z]+' 'Audio codec / extension / ffmpeg encoder (default=opus)'
	audioBitrate 'a?' "${REGEX['pint']}" 'Bitrate (kb/s) for opus audio (default=crf+codec-based)'
	src '$+' "${MIME_TYPES['video']}" 'File to cut/convert'
	dst '$?' '$d$D\.mp4' 'Output file/dir (default=`$src.mp4`)')
cut() {
	local crf=${crf:-28}
	local pickerFile=${MPV_PICKER_PICK_PATH%.pick}.lua
	cat >"$pickerFile" <<lua
		require 'mp'
		local crf=$crf
lua
	cat >>"$pickerFile" <<lua
		
		local function divmod(a, b) return a / b, a % b end
		
		local function getTime()
			local m, remainder = divmod(mp.get_property_number 'time-pos', 60)
			local h, m = divmod(m, 60)
			local s = math.floor(remainder)
			local ms = math.floor((remainder - s) * 1000)
			return string.format('%02d:%02d:%02d.%03d', h, m, s, ms)
		end
		
		_G.clips = {{}}
		_G.lastAction = {}

		local function getClipStr(clip)
			if not clip.file then return 'Empty clip' end
			return 'Clip: "' .. clip.file .. '"[' ..
					(clip.start or '0') .. ' - ' .. (clip['end'] or 'end') .. '] volume=' ..
					(clip.volume or 1) .. ' crf=' .. (clip.crf or crf)
		end
		local function printClip(clip)
			mp.osd_message(getClipStr(clip), 4)
		end

		local function getVol()
			return mp.get_property('mute') == 'yes' and 0 or mp.get_property_number 'volume' / 100
		end

		local function markClip()
			local clip = _G.clips[#_G.clips]
			if not clip.file then
				mp.osd_message('Clip empty', 2)
				return false
			end
			if not clip.start then clip.start = '0' end
			if not clip['end'] then clip['end'] = 'end' end
			if clip.volume ~= -1 then clip.volume = getVol() end
			if not clip.crf then clip.crf = crf end
			printClip(clip)

			_G.clips[#_G.clips + 1] = {}
			_G.lastAction = {}
			return true
		end

		local function writeAll()
			if not markClip() and #_G.clips == 1 then return false end -- autoconfirm last clip,
			_G.clips[#_G.clips] = nil

			local f = io.open(_G.pick_file, 'w')
			for _, clip in ipairs(_G.clips) do
				f:write(table.concat(
					{clip.file, clip.start, clip['end'], clip.volume, clip.crf},
					'\t'
				))
				f:write '\n'
			end
			f:close()
			return true
		end

		local function add(varName, value)
			if _G.clips[#_G.clips]['end'] and varName == 'start' then
				markClip()
			end

			if varName ~= _G.lastAction[#_G.lastAction] then
				_G.lastAction[#_G.lastAction+1] = varName
			end
			_G.clips[#_G.clips][varName] = value
			_G.clips[#_G.clips].file = mp.get_property('path')
			mp.osd_message(varName .. ' = ' .. value, 2)
		end

		local function dropClip()
			if #_G.clips > 1 then
				_G.clips[#_G.clips] = nil
				mp.osd_message('Clip removed', 2)
			else
				mp.osd_message('Already editing the first clip', 3)
			end
		end


		local function remove(varName)
			if not varName then
				while #_G.lastAction > 0 and not _G.clips[#_G.clips][_G.lastAction[#_G.lastAction]] do
					_G.lastAction[#_G.lastAction] = nil
				end

				if #_G.lastAction == 0 then
					mp.osd_message('Already default clip', 2)
					return
				end
				varName = _G.lastAction[#_G.lastAction]
				_G.lastAction[#_G.lastAction] = nil
			elseif not _G.clips[#_G.clips][varName] then
				mp.osd_message('Already undone clip.' .. varName, 2)
				return
			end

			mp.osd_message('Undone clip.' .. varName .. '=' .. _G.clips[#_G.clips][varName], 2)
			_G.clips[#_G.clips][varName] = nil
		end

		mp.add_key_binding('s', 'pickStart', function() add('start', getTime()) end)
		mp.add_key_binding('e', 'pickEnd', function() add('end', getTime()) end)
		mp.add_key_binding('v', 'pickVolume', function() add('volume', getVol()) end)
		mp.add_key_binding('Shift+s', 'dropStart', function() remove('start') end)
		mp.add_key_binding('Shift+e', 'dropEnd', function() remove('end') end)
		mp.add_key_binding('Shift+v', 'dropVolume', function() add('volume', -1) end)
		mp.add_key_binding('Alt+Enter', 'confirmClip', markClip)
		local function qualGen(change)
			return function()
				crf = crf + change
				add('crf', crf)
			end
		end
		mp.add_key_binding('Alt+q', 'incCrf', qualGen(1))
		mp.add_key_binding('Alt+Shift+q', 'decCrf', qualGen(-1))
		mp.add_key_binding('Shift+q', 'dropCrf', function() remove('crf') end)
		mp.add_key_binding('Enter', 'confirm', function()
			if writeAll() then
				mp.commandv 'quit'
			else
				mp.osd_message('No clips to process, set volume for full length', 3)
			end
		end)
		mp.add_key_binding('Alt+i', 'printClipInfo', function()
			local info = {}
			for _, clip in ipairs(_G.clips) do
				info[#info + 1] = getClipStr(clip)
			end
			mp.osd_message(table.concat(info, '\n'), 4)
		end)
		mp.add_key_binding('u', 'undoPrevAction', remove)
		mp.add_key_binding('d', 'dropClip', dropClip)
		mp.add_key_binding('h', 'help', function()
			mp.osd_message([[Create clips in the order you want them to be concatenated in.
<s> start a clip
<e> end a clip
<v> set clip volume (or disable when muted)
<Alt+q> increase clip crf (lower quality)
<Alt+Shift+q> decrease clip crf (higher quality)
<Shift+S/E/Q/V> reset clip param
<u> undo previous action
<d> drop all current params, edit last confirmed clip
<Alt+Enter> to confirm clip params (vol+crf automatically set to current)
<Enter> to process clips and quit]], 8)
		end)
		mp.osd_message('Press <h> for editing help', 3)

		_G.pick_file = '${MPV_PICKER_PICK_PATH}'
lua

	local _opts=(--msg-level=cplayer=error --loop-playlist --display-tags-clr --script="$pickerFile")

	while mpv "${_opts[@]}" "${src[@]}" && [[ ! -f $MPV_PICKER_PICK_PATH ]]; do
		echo 'You must use the keybindings to set the values'
	done
	rm "$pickerFile"
	[[ -f $MPV_PICKER_PICK_PATH ]] || return 1

	local clips=()

	local _cmd=($(ffmpegCmd) -i '<placeholder>')
	local fileArgPos=${#_cmd[@]}-1
	((metadata >= 0)) && _cmd+=(-map_metadata 0)
	if ((copy > 0)); then
		_cmd+=(-c copy)
		local ext=${src[0]##*.}
	else
		# decides only based on first source
		_cmd+=(-preset slow)
		[[ $audioBitrate ]] || local recAudio=$(ffprobe "${src[0]}" |&
			sed -n 's|.*Audio.*, \([0-9]\+\) kb/s.*|\1|p')
		if ((audioBitrate || ${recAudio:-0} > 105)); then
			declare -A codecMap=(
				[mp3]=libmp3lame
				[m4a]=aac
				[opus]=libopus
				[ogg]=libvorbis
				[vorbis]=libvorbis
			)
			[[ $audioEncoder ]] && audioEncoder=${codecMap["${audioEncoder}"]:-$audioEncoder}
			local audioEncoder=${audioEncoder:-libopus}
			_cmd+=(-c:a "$audioEncoder")
			((audioBitrate)) && _cmd+=(-b:a "${audioBitrate}k") # otherwise set based on crf
		else
			local audioBitrate=-1
			_cmd+=(-c:a copy)
		fi
		local ext=mp4
	fi

	while IFS=$'\t' read -ra line <&4; do
		local file=${line[0]} start=${line[1]} end=${line[2]} volume=${line[3]} crf=${line[4]}
		local cmd=("${_cmd[@]}" -crf "$crf")
		cmd[$fileArgPos]=$file
		if ! ((audioBitrate)); then
			if ((crf > 30)); then
				local ab=64
			elif ((crf > 26)); then
				local ab=48
			elif ((crf > 24)); then
				local ab=32
			else
				local ab=16
			fi

			if [[ $audioEncoder == libmp3lame ]]; then
				((ab *= 3))
			elif
				[[ $audioEncoder != libopus ]]
			then
				((ab *= 2))
			fi
			cmd+=(-b:a ${ab}k)
			log Info "[${file##*/}].audioBitrate = $ab"
		fi

		[[ $start != 0 ]] && cmd+=(-ss "$start")
		[[ $end != end ]] && cmd+=(-to "$end")

		if [[ $volume == 0 ]]; then
			cmd+=(-map v)
		elif [[ $volume != 1 && $copy -le 0 ]]; then
			cmd+=(-af volume="$volume")
		fi

		local out=/tmp/mom-$ACTION-${file##*/}_${start}_${end}.$ext
		exec "${cmd[@]}" "$out" || return 1
		clips+=("$out")
	done 4<"${MPV_PICKER_PICK_PATH}" # redirect input to keep ffmpeg user interaction

	if ((${#clips[@]} > 1)); then
		out=/tmp/mom-$ACTION.$ext
		local concatFile=/tmp/mom-$ACTION.txt
		printf 'file %s\n' "${clips[@]}" >"$concatFile"
		cmd=($(ffmpegCmd) -f concat -safe 0 -i "$concatFile" -i "$src" -c copy
		-map_metadata 1 -map 0 "$out")
		exec "${cmd[@]}" || return 1
		for clip in "${clips[@]}"; do
			rm "$clip"
		done
	fi

	local dst intermediary=$out
	determineOut
	exec mv "$intermediary" "$(getFreePath "$out")" &&
		if ((deleteSrc > 0 || (deleteSrc == 0 && ${#clips[@]} == 1))); then
			exec rm "${src[@]}"
		fi
}

actionInfo subtitles 'convert mp4 with srt to mkv'
subtitlesParams=(
	deleteSrc 'd?' '' 'Delete used files and subtitles'
	keepSrcSubs 's?' '' 'Keep original video file subs (disable if added subs are invisible)'
	defaultSubs 'D?' '[0-9]*' 'Set default subs track, -1 to leave unchanged (default=first added)'
	lang 'l*' '[a-z]+' 'Languages in order of provided subtitles (default={name}.srt|eng per sub)'
	# encoding '-e' "${REGEX[dashvar]}" 'wanted final encoding (requires `enca`; default=UTF-8)'
	rename 'r?' '' 'Rename using rename action, file $dst has priority'
	subs '$*' '$f\.srt' 'Subtitles to add (default=*.srt)'
	vid '$?' "${MIME_TYPES['video']}" 'Source video file (default=first of `*.mp4`,`*.mkv`)'
	dst '$?' '$d$D\.mkv' 'Output file (default=`$vid.mkv`)')
# subtitle format from windows transcoding using `enca` package
# for scale/speed/alignment adjustment use `ffmpeg -itsscale 1.001 -i *.srt -c copy out.srt`
subtitles() {
	if [[ -z $subs ]]; then
		local subs=(*.srt)
		if [[ $vid && ${#subs[@]} -gt 1 ]]; then
			local match=${vid@L}
			match=${match%.*}.srt
			match=${match##*/}
			for src in *.srt; do
				if [[ ${src@L} == "$match" ]]; then
					local subs=("$src")
					break
				fi
			done
		fi

		if [[ -z $subs ]]; then
			log Error " - no match for '$match'"
			return 1
		fi
	fi

	[[ $vid == *.mkv && ! -f $vid && -z $dst ]] && local dst=$vid && vid=
	if [[ -z $vid ]]; then
		local vid=(*.mp4)
		if [[ ${#vid[@]} -ne 1 ]]; then
			local match=${subs@L}
			match=${match%.*}.
			match=${match##*/}
			vid=()
			for src in *.mp4 *.mkv; do
				if [[ ${src@L} == "$match"* ]]; then
					local vid=$src
					break
				fi
			done
		fi

		if [[ -z $vid ]]; then
			log Error " - no match for '$match'"
			return 1
		fi
	fi

	# [[ $encoding ]] || local encoding=UTF-8
	local cmd=($(ffmpegCmd))

	local sub i len=${#subs[@]}
	for sub in "${subs[@]}"; do
		# if [[ $(file "$sub" -b) =~ ([^ ]+)\ text && ${BASH_REMATCH[1]} != $encoding ]]; then
		# enca "$sub" -x "$encoding"
		# fi
		cmd+=(-i "$sub")
	done
	# add video as the last source to simplify subtitle track indexes
	cmd+=(-i "$vid" -map $len:a -map $len:v -c copy)

	declare -i origSubCount=$(ffprobe "$vid" |& grep Subtitle | wc -l)
	((keepSrcSubs > 0 && origSubCount > 0)) && cmd+=(-map $len:s)

	[[ $lang ]] || local lang=()
	for ((i = 0; i < len; i++)); do
		if [[ -z ${lang[i]} ]]; then
			sub=${subs[i]##*/}
			[[ $sub == [a-z][a-z][a-z].srt ]] && lang[i]=${sub%.srt} || lang[i]=eng
			log Info "['${subs[i]/*\//…/}'].lang = ${lang[i]}"
		fi
		cmd+=(-map $i -metadata:s:s:$i language=${lang[i]})
	done

	((defaultSubs > 0)) && cmd+=(-disposition:s:$((defaultSubs - 1)) default)
	local src=$vid ext=mkv out dst=${dst}
	determineOut

	runCmdWithCleanup && if ((deleteSrc > 0)); then
		exec rm "${subs[@]}"
	fi
}

pickSong() {
	declare -n _choice=$1
	if ((SCRIPT_OPTS['guiPicker'] > 0)); then
		local cmd=(rofi -dmenu -i -multi-select -p "$4" -theme-str 'window {width: 50%;}')
	else
		local cmd=(fzf -m --prompt "$4: ")
	fi
	readarray -t _choice < <({
		find ~/Music/* -type d 2>/dev/null
		find "${MUSIC_SOURCES[@]:-$HOME/Music/Songs}" -type f 2>/dev/null
	} | "${cmd[@]}")

	((${#_choice[@]}))
}

actionInfo play 'select and play a song/dir using mpv'
playParams=(
	loop 'l?' '' 'Loop playlist (default=true when playing folders)'
	daemonize 'd?' '' 'Run as a separate process with no controlls (default=true for GUI use)'
	randomizer 'r?' '((a([0-9]*)|d([0-9]*)(:[0-9]+)?)s?)?'
	'(default=false) true=mpv --shuffle; a<f>= <f> picks per artist/final dir;
       d<n>:<f>= <n> final dir picks, <f> picks per dir, *`s` for --shuffle after picks'
	kill 'k?' '' 'Should all previous players be killed (default=true)'
	src '$+' '$e' 'Play files or dirs')
declare -A playBuilder=([src]=pickSong)
play() {
	local daemonize=${daemonize:-${SCRIPT_OPTS[guiPicker]}}
	local playlistFile=/tmp/mom-$ACTION
	local cmd=(mpv --no-audio-display --playlist="$playlistFile")
	((kill >= 0)) && exec pkill -f "${cmd[*]}" >/dev/null # ensure only one music instance is running

	[[ -f $playlistFile ]] && exec rm "$playlistFile"

	declare -i files
	local srcF
	for srcF in "${src[@]}"; do
		if [[ -f $srcF ]]; then
			[[ $srcF == /* ]] || srcF=$PWD/$srcF # make absolute path
			exec echo "$srcF" \>\> "$playlistFile"
			((files += 1))
		elif [[ -d $srcF ]]; then
			[[ $randomizer != [da]* ]] && exec fd '' -tf -tl "$srcF" \>\> "$playlistFile"
		else
			log Error "Invalid src path: \"$srcF\""
		fi
	done

	if [[ $files == 1 && -f $src ]]; then # expand the directory, if it was the only file arg
		cmd+=(--playlist-start=0)
		src=${src%/*}
		[[ $randomizer != [da]* ]] && exec fd '' -tf -tl "$src" \>\> "$playlistFile"
	fi

	if [[ $files -le 1 && $randomizer == [da]* ]]; then # directory processing
		local artistDirs=() d f
		for tmp in "${src[@]}"; do
			[[ -f $srcF ]] && continue
			[[ $srcF == /* ]] || srcF=$PWD/$srcF
			while read -r d; do # filter out dirs with no files
				for f in "$d"/*; do
					if [[ -f $f ]]; then
						artistDirs+=("$d")
						break
					fi
				done
			done < <(
				echo "$srcF"
				fd '' -Lt d "$srcF" | sort -R
			)
		done

		[[ $randomizer =~ ^[da]([0-9]*)(:([0-9]+))?s?$ ]]
		if [[ $randomizer == d* ]]; then
			declare -i n=${BASH_REMATCH[1]:-1} perDir=${BASH_REMATCH[3]:-1}
		else
			declare -i n=${#artistDirs[@]} perDir=${BASH_REMATCH[1]:-1}
		fi

		local matcher="${MIME_TYPES['audio']}"
		while ((n-- > 0)); do
			declare -i picked=0
			while read -r f; do
				if argMatch "$f"; then
					exec echo "$f" \>\> "$playlistFile"
					(((picked += 1) < perDir)) || break
				fi
			done < <(fd '' -Lt f --max-depth=1 "${artistDirs[n]}" | sort -R)
		done
		unset matcher
	fi

	if [[ $randomizer == *s || $randomizer -gt 0 ]]; then
		mv "$playlistFile" '/tmp/test'
		sort -R -u '/tmp/test' >"$playlistFile"
		rm '/tmp/test'
	fi

	((loop == 0)) && ((loop = (files <= 1) * 2 - 1))
	((daemonize > 0)) && cmd+=(--no-terminal)
	if [[ $randomizer == [ad]* ]]; then
		exec "${cmd[@]}" && if ((loop > 0)); then
			local args=($ACTION -l -r$randomizer "${src[@]}")

			if ((daemonize > 0)); then # daemonized by launching the same cmd, but in the bg
				exec "$0" "${args[@]}" -d \&
				disown
			else
				call "${args[@]}" +d
			fi
		fi
	else
		((loop > 0)) && cmd+=(--loop-playlist)
		if ((daemonize > 0)); then
			log Verbose && log Verbose " \$> ${cmd[*]} &"
			nohup "${cmd[@]}" &>/dev/null &
			disown # for whatever reason cmds launched via terminal, but from desktop ignore disown
			sleep 1
		else
			exec "${cmd[@]}"
		fi
	fi
	exec rm "$playlistFile"
}

actionInfo linkFix 'fix symlinked files - find new paths, allowing slightly modified names+ft'
linkFixParams=(
	target 't?' '$d' 'Dir with broken links (default=./)'
	resources '$!' '$d' 'Dir with reference files')
linkFix() {
	[[ $target ]] && target=${target%/}/ || local target=${target:-./}
	local CWD=$PWD
	cd "$target"
	local f
	while read f; do
		if [[ ! -e $f ]]; then
			local song=${f##* [-/] } fileName=${f##*/}
			song=${song%%' ('*}
			song=${song%%.*}
			song=${song//\(/\\(}
			song=${song//\)/\\)}
			local all="" found= ptn="${fileName%% -*}[^/]*[/-][^/]*$song"
			while read found; do
				if ((${#all} && ${#all} < ${#found})); then
					log Info ": unused match '$found' to '$f'"
				else
					if ((${#all})); then
						log Info ": unused match '$all' to '$f'"
					fi
					all=$found
				fi
			done < <(fd -t f -p "$ptn" "$resources")

			if [[ $all ]]; then
				exec rm "$f" # remove in case the extension has changed
				exec ln -sf "$(realpath -s --relative-to="${f%/*}" "$all")" "${f%.*}.${all##*.}"
			else # TODO: use fzf to find the file manually
				log Warn ": unmatched $f"
			fi
		fi
	done < <(fd -t l .)
	cd "$CWD"
}

actionInfo resize 'resize images'
resizeParams=(
	deleteSrc 'd?' '' 'Delete $src file'
	rename 'r?' '' 'Rename using rename action, file $dst has priority'
	src '$+' "${MIME_TYPES['image']}" 'Files to convert'
	quality 'q?' '[0-9]+' 'Change image quality (default=imagemagick default)'
	predicate 'p*' '[0-9]+%?[+-]' 'Source size requirement, pixels or % of the target size
       (comparing to dimension selected by --size)'
	size 's?' 'x?[0-9]+[x^%]?' 'Longest side px, *`^`=shortest, *`x`*=width/height, *`%`'
	dst '$?' '$d$D\.(jpe?g|png|heif|jxl|avif)' 'Output file / dir with target extension (default=$src)'
)
resize() {
	if matcher='$D[^/]\.[^ ]+' argMatch "$dst" && ((${#src[@]} > 1)); then
		log Error ' - cannot specify multiple $src and a file $dst'
		return 1
	fi

	declare -i i=-1 srcN=${#src[@]}
	local only=${only:->} size=${size:-'100%'}
	function isolated() {
		declare -ai dim=($(magick identify -auto-orient -format '%w %h' "$src"))
		# imagemagick would understand, but it's easier to reuse our shortest side checker
		local oldSize=$size size=$size
		[[ $size == x* ]] && size=${size:1} && ((dim[0] > dim[1])) && size+=^
		[[ $size == *x ]] && size=${size::-1} && ((dim[0] < dim[1])) && size+=^

		if [[ $size == *'%' ]]; then
			((dim[0] < dim[1])) && dim=(${dim[1]} ${dim[0]}) # scale by the longer side
			((size = dim * ${size::-1} / 100))
		fi

		[[ $oldSize != $size ]] && log Verbose ".size: $oldSize → $size"

		local out ext dst=${dst}
		determineOut

		if [[ $predicate ]]; then
			local pred
			for pred in "${predicate[@]}"; do
				((dim[0] < dim[1])) && dim=(${dim[1]} ${dim[0]})
				local gap=${pred::-1} only=${pred:0-1} # number + sign
				if [[ $gap == *% ]]; then
					((gap = ${gap%'%'} * ${size%'^'} / 100))
					log Verbose ".predicate: $pred → $gap$only"
				fi

				# select compared dimension - `^` for shortest side
				[[ $size == *^ ]] && dim=${dim[1]}

				# require distance to target size greater/lower or equal to $gap
				if ! [[ ($only == + && $dim -ge $gap) || ($only == - && $dim -le $gap) ]]; then
					if [[ ${src#./} != ${out#./} ]]; then # no conversion, only move to destination
						exec $( ((deleteSrc <= 0)) && echo cp || echo mv) "$src" "${out%.*}.${src##*.}"
					fi
					log Info ": ${dim}px != <${gap}px${only}> → skipping"
					return
				fi
			done
		fi

		if [[ $size != *^ && $size != *x* ]]; then
			size="${size}x$size" # enforcement of long side (magick mangles it with short otherwise)
		fi

		local cmd=(magick "$src" -auto-orient -resize "$size")
		((quality)) && cmd+=(-quality $quality)

		runCmdWithCleanup
	}
	fn=isolated runJobs jobSrcDistributor $(seq 0 $((srcN - 1)))
}

arrayToMap() {
	declare -n map=$2 array=$1
	local delimiter=${3:-'[:=]'}

	for item in "${array[@]}"; do
		map[${item/$delimiter*/}]=${item#*$delimiter}
	done
}

actionInfo rename R 'rename video/image files using `exiftool` with `sed` fallback'
renameParams=(
	format 'f*' '[^:]+[:=].*' 'Exiftool format per argMatch expression (last match used)'
	fallback 'F*' '[^:]+[:=].*' 'Sed fallback expression per argMatch expression (last match used)'
	dateFormat 'd!' '.+' 'Timestamp format'
	dateFallback 'D?' '' 'Use file mod time for timestamp fallback (default=ask)'
	allowOverwrite 'o?' '' 'Allow renaming to itself in printOnly mode (default=true)'
	printOnly 'p?' '' 'Print the final dst instead of moving'
	src '$+' "\$d${MIME_TYPES['image']}${MIME_TYPES['audio']}${MIME_TYPES['video']}" 'File to rename'
	dst '$?' '$d$D' 'Output file / dir with target extension (default=$(basename $src)/…)'
)
renameConfig=(
	format=${MIME_TYPES['audio']}:'$Artist - $Title'
	format='$f.mov:$DateTimeOriginal'
	format='$f^VID[^ .]*.mp4:$CreateDate'
	format=${MIME_TYPES['image']}:'$DateTimeOriginal'
	fallback=${MIME_TYPES['video']}:'s,\., ,g;s,^(.*/)?(.*) ([0-9]{4}) .*$,\1\3 \2,' # movies
	fallback=${MIME_TYPES['audio']}:'s,.*/([A-Z][a-z]+( \w+)+).*/([0-9.]+|.*-) ([^_/]+)(_[0-9]*)?$,\1 - \4,'
	fallback=${MIME_TYPES['image']}:'s,IMG-(....)(..)(..)-(WA....)$,\1-\2-\3_\4,'
	dateFormat='%Y-%m-%d_%H%M%S'
)
rename() {
	if [[ ${#src[@]} -gt 1 && -d ${src[-1]} && -z $dst ]]; then # dst dir parsed as src
		local dst=${src[-1]}
		src=("${src[@]::${#src[@]}-1}")
	fi

	if [[ ${#src[@]} -gt 1 || -d $src ]]; then
		traverse() {
			for src in "$@"; do
				if matcher=${renameParams[-6]} argMatch "$src"; then
					if [[ -d $src ]]; then
						traverse "$src"/*
					else
						src="$src" runJob rename
					fi
				fi
			done
		}
		traverse "${src[@]}"
		wait
		return 0
	fi

	ACTION+="['${src/*\//…/}']"
	local name=${src##*/}
	declare -i i=${#format[@]}

	while ((i-- > 0)); do
		if matcher=${format[$i]/:*/} argMatch "$src"; then
			local exif=${format[$i]#*:}
			break
		fi
	done
	log Debug ".exif = '$exif'"

	i=${#fallback[@]}
	while ((i-- > 0)); do
		if matcher=${fallback[$i]/:*/} argMatch "$src"; then
			local sed=${fallback[$i]#*:}
			break
		fi
	done
	log Debug ".sed = '$sed'"

	local name=''
	if [[ $exif ]] && {
		{ # exiftool
			name=$( # regex creates cond to check all exif vars have a value
				exiftool "$src" -d "$dateFormat" -p "$exif" -if "$(
					echo "$exif" | sed 's/^[^$]*//;s/\(\$\w\+\)[^$]*/\1 and /g;s/ and $//'
				)" 2>/dev/null
			) && [[ $name ]]
		} || { # date fallback (for images); relies on datetime being the only exif var
			[[ $dateFallback -ge 0 && $exif =~ ^[^$]*\$DateTimeOriginal[^$]*$ ]] && {
				name="${exif/'$DateTimeOriginal'*/}$(
					date -r "$src" +"$dateFormat"
				)${exif/*'$DateTimeOriginal'/}"
				[[ $name == "${src%.*}" ]] && dateFallback=1

				if ((!dateFallback)); then
					local dateFallback
					read -p "$(
						print "rename '$src' to file mod date = '$name.$ext'? [y/N]: "
					)" -n1 dateFallback
					[[ $dateFallback ]] && echo # fixes missing newline after user input
					[[ $dateFallback == [yY]* ]] && dateFallback=$?
				fi
			}
		}
	} || { # sed fallback
		[[ $sed ]] && {
			[[ $src == *[^.]/* ]] || src=$PWD/${src#./}
			name=$(echo "${src%.*}" | sed -E "$sed")
			[[ $exif ]] &&
				log Warn " - using fallback: '${name##*/}.$ext'"
			[[ $name ]]
		}
	}; then
		local out= ext= dst=${dst:-.}
		rename=-1 determineOut # extract the extension from dst
		out=${out%/*}/${name##*/}.${ext/jpeg/jpg}

		# ensure shortest path versions for identicity checking
		stripPWD src
		stripPWD out

		# allowOverwrite is for print_only for use in other functions
		if ((printOnly)); then
			[[ $src == "$out" && $allowOverwrite -le 0 ]] && out=$(ACTION+=.dst getFreePath "$out")
			echo "$out"
		elif [[ $src != "$out" ]]; then
			out=$(ACTION+=.dst getFreePath "$out") # cannot override itself
			exec mv -i "$src" "$out"
		else
			log Verbose " - already correct"
		fi
	else
		log Info " - skipping"
	fi
}

main "$@"
