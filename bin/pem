#!/usr/bin/bash

. sss

SSS_OPTS[about]='PEM - Photo Exif Manipulation
A builder with various predefined filters by exif data
and various actions to execute on the filtered files'

# get exiftool query specified by $query on the $f
getExif() {
	exiftool -n -p "${1:-$query}" "$f" 2>/dev/null
}

# expects vars: $query/$extra - queries, $f - filename (required)
# sets $exif=()
setExif() {
	exif=($(getExif "${1:-$query} $extra"))
}
# expects vars: $pre/$post/$extra - queries, $f - filename (required)
# sets $exif=(), flIdx
exifWithIntFl() {
	setExif "$pre "'${FocalLength;$_=int($_)}'" $post"
	[[ $pre ]] && local preSpace="${pre//[^ ]/} "
	declare -gi flIdx=${#preSpace}
}

dummyFilter() {
	:
}

flFilter() {
	# skip photos from a phone and undefined
	exifWithIntFl && ((exif[flIdx] >= 8))
}

flNoApFilter() {
	post="\$FNumber $post" flFilter && [[ ${exif[flIdx + 1]} != [0-9]* ]]
}

FILTERS=($(declare -f | sed -n 's/^\(\w*\)Filter ()\s$/\1/p'))

actionInfo execute x 'e[x]ecute' 'filter photos using a custom filter and execute a custom fn on them'
executeParams=(
	forEach 'e?' "${REGEX['var']}" 'Which function to execute (default: `forEach`);
      passes in the filename as $f, exif as var,
      $forEach is usually set by one of the builder actions'
	after 'a?' ".*" 'Require filename to be alphabetically after given string'
	before 'b?' ".*" 'Require filename to be alphabetically before given string'
	condition 'c!' "$(printf "%s|" "${FILTERS[@]}").+"
	'Filter fn for what to parse with $forEach
      use a predefined filter, pass in the fn name as defined in your config,
      or pass in the full function code via `declare -f`
      it should create an $exif array with all used exif data - provides data to $forEach
      - use `setExif <query>` or `pre=<> post=<> exifWithIntFl` or any of the filters'
	finally 'f?' "${REGEX['var']}" 'What to run on the output of all the processed files (default: finally)'
	src '$*' '$e' 'Where to look for the files to process (default: .)'
)
execute() {
	local forEach=${forEach:-forEach}
	declare -f $forEach &>/dev/null || log Error ".forEach: Function $forEach() not defined"

	local condition=$condition
	if [[ $condition == *'()'* ]]; then
		exec eval "$condition"
		condition=${condition/ */}
	elif declare -f "${condition}Filter" &>/dev/null; then
		condition=${condition}Filter
	elif ! declare -f "$condition" &>/dev/null; then
		log Error ".condition: Function $condition() not defined"
	fi

	if [[ $finally ]]; then
		declare -f $finally &>/dev/null || log Error ".finally: Function $finally() not defined"
	elif declare -f finally &>/dev/null; then
		local finally=finally
	else
		local finally=cat
	fi

	local f
	runner() { "$condition" && "$forEach"; }
	if [[ -f $src ]]; then
		local getSrc
		for getSrc in "${src[@]}"; do
			[[ -f $getSrc ]] || log Error '.src: Source list contains both files and directories'
		done
		local getSrc=(printf "%s\n" "${src[@]}")
	else
		local getSrc=(fd -L -t f -e jxl -e avif -e jpg -e raf '' "${src[@]}")
	fi
	local before=${before:-'~'} # last printable char from ascii as default
	{
		while read -r f; do
			# skip photos from before I got a camera
			[[ ${f##*/} > $after && ${f##*/} < $before ]] && runJob runner
		done < <("${getSrc[@]}")

		wait
	} | "$finally"
}

actionInfo categorize 'sort all files into folders by the first `exif` value from the filter'
categorizeParams=(
	dst '$!' '$F' 'Directory to link the folders with categorized files to'
)
categorize() {
	exec mkdir -p "$dst"
	DST=$dst
	forEach() {
		local path="$DST/$exif"
		exec mkdir -p $path
		exec ln -s "$PWD/$f" "$path/${f##*/}"
	}
}

actionInfo stats 'display statistics of given exif parameter (sorts and groups by the first exif value)'
stats() {
	forEach() { echo "${exif[@]}"; }
	finally() { sort -n | uniq -c; }
}

actionInfo ratedStats 'display statistics of photos to their overal rating per focal length'
ratedStatsParams=(
	key 'k?' '[1-4](,[1-4])*' 'Sort by which key(s) (columns: focalLength count ratingSum ratio)'
	skipUndef 's?' '' 'Should we skip images without Rating or count them as 0 (default)'
)
ratedStats() {
	if ((skipUndef > 0)); then
		forEach() { [[ ${exif[-1]} == R? ]] && echo "${exif[@]::${#exif[@]}-1}" "${exif[-1]#R}"; }
	else
		forEach() {
			[[ ${exif[-1]} == R ]] && exif[-1]=0 || exif[-1]=${exif[-1]#R}
			echo "${exif[@]}"
		}
	fi
	finally() {
		declare -ai counts ratings
		local exif
		while read -ra exif; do
			counts[$exif]+=1
			ratings[$exif]+=${exif[-1]}
		done

		local fl
		for fl in "${!counts[@]}"; do
			printf "%3d %4d %4d %3d%%\n" "$fl" "${counts[$fl]}" "${ratings[$fl]}" "$((20 * ${ratings[$fl]} / ${counts[$fl]}))"
		done | sort -n -k "${key:-1}"
	}
	extra='R$Rating' call execute -c fl
}

actionInfo edit 'set value of given tag on filtered files'
editParams=(
	tags 't+' "${REGEX['var']}" 'List of tags to edit'
	values 'v*' '.*' 'List of values or references to what value to set the respective tags to;
      terminate them with `$` to ensure the picker will not default to other choices,
      lead and terminate with `$` to call a fn - $1=filename (value like `$transformFn$`)'
)
edit() { # TODO: add a visual filter (opens swayimg with a shortcut for confirming each image)
	TAGS=("${tags[@]}")
	VALUES=("${values[@]}")
	forEach() {
		local value defaults=()

		declare -i len=${#TAGS[@]}
		for ((i = 0; i < len; i++)); do
			local tag=${TAGS[i]}
			local def=("$(query="\$$tag" getExif)")
			if [[ -z ${VALUES[i]} ]]; then
				choiceList=def pickFromList value 'v!' '.+' "Set \$${tag}"
			else
				value=${VALUES[i]}
			fi

			if [[ $value && $value != $def ]]; then
				if [[ $value == '$'?*'$' ]]; then # call a custom fn to retrieve the value
					value=$(${value//'$'/})
				elif [[ $value == *'$'?* ]]; then # reference pattern string
					value="$(query="$value" getExif)"
				else
					value="${value%'$'}"
				fi

				exec exiftool -$tag="$value" -overwrite_original_in_place "$f"
			fi
		done
	}
}

if [[ $0 == *pem ]]; then
	main "$@"
fi
