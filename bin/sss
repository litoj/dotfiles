#!/usr/bin/bash

LC_ALL=C # improves regex by ~10%
declare -A ACTION_INFO=()
declare -a ACTION_ORDER=()
ALIGNER=8

argToCase() {
	if [[ $1 != *-* ]]; then
		echo "$1"
		return
	fi

	local str=${1#*-}
	local ret=${1%%-*}
	local part
	while [[ $str == *-* ]]; do
		part=${str%%-*}
		ret+=${part^}
		str=${str#*-}
	done
	echo "$ret${str^}"
}
caseToArg() {
	if [[ $1 != *[A-Z]* ]]; then # no uppercase letters
		echo "${1//_/-}"
		return
	fi

	local str=$1
	local ret=''
	while [[ $str =~ ^([a-z0-9]+)([A-Z]+)(.*)$ ]]; do
		ret+=${BASH_REMATCH[1]}-
		((${#BASH_REMATCH[2]} < 2)) && ret+=${BASH_REMATCH[2],} || ret+=${BASH_REMATCH[2]}
		str=${BASH_REMATCH[3]}
	done
	echo "$ret$str"
}
# run testFn=$2 until the correct case of arg=$1 is found
detectCase() {
	local arg=$1 test=$2 ret=$1
	"$test" "$ret" || { # test unprocessed
		ret=$(argToCase "$arg")
		"$test" "$ret" # camelCase test
	} || {
		ret=${arg//-/_}
		"$test" "$ret" # snake_case test
	} || return 1

	echo "$ret"
}

#######################################
# Register fn/action docs and for execution
# Arguments:
#   name: name of the function
#   key?: a unique one-letter shortcut for calling, or '' for no shortcut
#   helpsig?: function name displayed in help (with bracket-highlighted key)
#   help: help text
#######################################
actionInfo() {
	local name=$1 key helpsig help=${!#}
	(($# > 2)) && key=$2 || key=${name::1}
	if (($# > 3)); then
		helpsig=$3
	else
		local converted=$(caseToArg "$name")
		[[ $key ]] && helpsig="[$key]${converted:1}" || helpsig=$converted
	fi
	[[ $key ]] && ACTION_INFO["$key"]="$name"
	((ALIGNER < ${#helpsig})) && ALIGNER=${#helpsig}
	ACTION_INFO["$name"]="$helpsig $help"
	ACTION_ORDER+=("$name")
}

declare -A LOG_LEVELS=([quiet]=0 [fatal]=1 [error]=2 [warn]=3
	[warning]=3 [info]=4 [verbose]=5 [debug]=6 [trace]=7)
LOG_NAMES=(quiet fatal error warn info verbose debug trace)

[[ $# == 0 && -t 0 && -t 1 ]]
declare -Ai SCRIPT_OPTS=( # helper + runtime options - changeable by `define` action
	[cli]=$? # user currently runs in CLI
	[tui]=$((1 - $?))
	[dryRun]=0
	[color]=0
	[guiPicker]=0
	[argPicker]=0
	[optArgPicker]=1
	[ignoreFailedPicker]=0
	[logLvl]=${LOG_LEVELS['info']}
)
[[ -t 0 && -t 1 && -t 2 ]] && SCRIPT_OPTS[color]=1
[[ -t 0 ]] || SCRIPT_OPTS[guiPicker]=1 SCRIPT_OPTS[argPicker]=1

actionInfo define D 'set script-processing options'
defineParams=(
	tui 'T?' '' 'Enter TUI after CLI is parsed'
	dryRun 'D?' '' 'Disable actual commands execution'
	color 'C?' '' 'Colorize output (default=1 when not redirected)'
	config 'c*' '$f\.conf\.sh$|-?' "Config file as arrays of cli options like \`defineConfig+=(-l3)\`,
       or \`+c\` to unload all configs (default='~/.config/${0/*\//}.conf.sh')"
	guiPicker 'G?' '' 'Use GUI pickers (default=true when stdin is missing)'
	argPicker 'A?' '' 'Enable arg picker (default=true when stdin is missing)'
	optArgPicker 'O?' '' 'Enable picker for option arguments (default=true)'
	ignoreFailedPicker 'I?' '' 'Discard option when picker returned no value'
	logLvl 'l?' '([0-9]+|[A-Za-km-z]+)?'
	"Depth of logging, -lll=-l3â€¦\
 (default=${LOG_NAMES[${SCRIPT_OPTS['logLvl']}]}=${SCRIPT_OPTS['logLvl']})"
)
defineParams+=(logLvl '$?' "${defineParams[@]:0-2}")
SCRIPT_OPTS[logLvl]=${LOG_LEVELS["${DEBUG:-x}"]:-${DEBUG:-${SCRIPT_OPTS['logLvl']}}}
define() {
	declare -i i=0
	local opt
	while [[ ${defineParams[i]} ]]; do # opts with an arg value
		opt=${defineParams[i]}
		if [[ ! ${!opt} ]]; then
			:
		elif [[ -z ${defineParams[i + 2]} ]]; then
			SCRIPT_OPTS["$opt"]=${!opt}
		elif [[ $opt == config ]]; then
			declare -n opt
			local x
			for x in "${opt[@]}"; do
				if [[ $x =~ ^-?[0-9]*$ ]]; then
					if [[ $x == - || $x -lt 0 ]]; then
						local _act
						for _act in "${ACTION_ORDER[@]}"; do
							unset "${_act}Config"
						done
						unset _act
						continue
					else
						x=${XDG_CONFIG_HOME:-$HOME/.config}/${0/*\//}.conf.sh
					fi
				fi

				if [[ -f $x ]]; then
					log Debug ".config['$x'] - loading"
					if config= source "$x"; then
						log Verbose ".config['$x'] - successfully loaded"
					else
						log Error ".config['$x'] - invalid syntax"
					fi
				elif [[ $ACTION == define ]]; then # called by user
					log Warn ".config['$x'] doesn't exist"
				fi
			done
			declare +n opt
		elif [[ ${!opt} ]]; then
			if [[ ${!opt} == [A-Za-z]* && ! ${LOG_LEVELS["${!opt,,}"]} ]]; then
				[[ $opt == logLvl ]] &&
					SCRIPT_OPTS["$opt"]=${LOG_LEVELS['info']} ||
					SCRIPT_OPTS["$opt"]=${LOG_LEVELS['warn']}
				log Warn ".$opt - unknown log level '${!opt}', defaulting to '${LOG_NAMES[${SCRIPT_OPTS["$opt"]}]}'
  Available are: ${LOG_NAMES[*]}"
			else
				if [[ ${!opt} == -* ]]; then
					((SCRIPT_OPTS["$opt"] += ${!opt}))
				else
					SCRIPT_OPTS["$opt"]=${LOG_LEVELS["${!opt,,}"]:-${!opt}}
				fi
			fi
		fi
		unset "$opt" # to not parse multiopt twice
		i+=4
	done
	return 0
}

exitFn() {
	if [[ $ACTION ]]; then
		if [[ $i ]]; then
			paramHelp "$ACTION" 1 $((i / 4))
		else
			call help -pm "$ACTION"
		fi
	fi
	exit $1
}

declare -A SSS_OPTS=( # internal behaviour / parsing options - script-specific edge case handling
	[about]=''                               # script description
	[exitFn]=exitFn                          # on error / on successful exit - shouldn't return
	[exitLogLvl]=$((1 + SCRIPT_OPTS['cli'])) # at which level to abort (cli:Error, tui:Fatal)
	# set to main registered action if script is a single command - actions act as builders
	# you can also change other actions' params at runtime â†’ dynamic configuration
	# builder example: --builder init1 --builderOption --builder init2 'default action arg'
	[defAction]=unknown # when no other action matches args, actionInfo register optional
	[defActionLast]=1   # default action can't be followed by other actions (must consume all args)
	[optPrefix]='-{,2}' # regex for required cli long name format
	[argAsLongOpt]=1    # allow arguments to be also parsed as long options
	[onNoArg]=0         # >0: pick also chained opts; 0: try num arg (+=1); <0: pick non-chained opts
)

declare -A COLORS=(
	[black]=30 [red]=31 [green]=32 [yellow]=33 [blue]=34 [magenta]=35 [cyan]=36 [brgray]=37
	[gray]=90 [brred]=91 [brgreen]=92 [bryellow]=93 [brblue]=94
	[brmagenta]=95 [brcyan]=96 [white]=97
	# effects
	[bg]=30 [fg]=97 [reset]=0
	[bold]=1 [italic]=3 [underline]=4 [reverse]=7 [strike]=9
	[nobold]=22 [noitalic]=23 [nounderline]=24 [noreverse]=27 [nostrike]=29
	# log level colors
	[quiet]=0 [error]=31 [warn]=33 [info]=32 [verbose]=35 [debug]=37 [trace]=90
	# theme colors
	[oper]=31 [delim]=91 [bool]=34 [var]=32 [param]=96 [str]=33 [num]=95 [def]=3 # def=define
)
ansi() {
	local ret code
	while (($#)); do
		[[ -z $1 || $1 == *[^a-z]* ]] && code= || code=${COLORS["$1"]}
		[[ $code ]] && ret+="[${code}m" || ret+=$1
		shift
	done
	echo "$ret"
}
print() {
	if ((SCRIPT_OPTS['color'] <= 0)); then
		echo "$@"
		return
	fi

	local ret str="$1" hlStr
	while [[ $str ]]; do
		case "$str" in # 25% speed increase over regex matches
			false* | true*)
				[[ $str == t* ]] && hlStr=true || hlStr=false
				ret+="$(ansi bool "$hlStr" fg)" str=${str:${#hlStr}}
				;;
			'default='*) ret+=$(ansi def 'default' noitalic) str=${str:7} ;;
			[A-Za-z]*) hlStr=${str/[^0-9A-Za-z]*/} ret+=$hlStr str=${str:${#hlStr}} ;;
			[.:[\]{}]*) ret+=$(ansi delim "${str::1}" fg) str=${str:1} ;;
			[*+?!=\<\>^\|/%]*) ret+=$(ansi oper "${str::1}" fg) str=${str:1} ;;
			-*)
				if [[ ${str:1:1} == [0-9\ ] ]]; then
					ret+=$(ansi oper - fg)
					str=${str:1}
				elif [[ ${ret:0-2} == [A-Za-z][A-Za-z] || ${ret:0-1} == [A-Za-ln-z] ]]; then
					hlStr=${str/[^A-Za-z\-]*/}
					ret+=$hlStr
					str=${str:${#hlStr}}
				else
					hlStr=${str/[^0-9A-Z[\]_a-z\-]*/}
					ret+=$(ansi param "$hlStr" fg)
					str=${str:${#hlStr}}
				fi
				;;
			[\'\"\`]*)
				local delim=${str::1} _str=${str:1} str=${str:1}
				if [[ -z $str ]]; then
					ret+=$delim
					continue
				fi
				hlStr=
				while [[ -z $hlStr || ${str:${#hlStr}:1} == [a-zA-Z] ]]; do
					hlStr+=${_str/${delim}*/$delim}
					[[ ${hlStr:0-1} == "$delim" ]] && _str=${str:${#hlStr}}
				done
				unset _str
				[[ ${hlStr:0-1} != "$delim" ]] && hlStr='' ret+=$delim || ret+=$(ansi str "$delim$hlStr" fg)
				str=${str:${#hlStr}}
				;;
			[0-9]*) hlStr=${str/[^0-9_]*/} ret+=$(ansi num "$hlStr" fg) str=${str:${#hlStr}} ;;
			'['*) hlStr=${str/m*/} ret+=$hlStr str=${str:${#hlStr}} ;;
			[\$]*)
				local delim=${str::1}
				str=${str:1}
				hlStr=${str/[^0-9A-Za-z_\-]*/}
				ret+=$(ansi delim "$delim" var "$hlStr" fg)
				str=${str:${#hlStr}}
				;;
			*) ret+=${str::1} str=${str:1} ;;
		esac
	done

	echo "$ret"
}

#######################################
# Print given message with context of current action and log level
# Arguments:
#   LAST_LOG_LVL: one of ${LOG_LEVELS[@]}, determines message importance
#   msg: message to print with context, ignored when SCRIPT_OPTS[logLvl]<LAST_LOG_LVL
# Returns:
#   success or no return (calls exitFn)
#######################################
log() {
	LAST_LOG_LVL=${LOG_LEVELS["${1,,}"]:-$1}
	if ((SCRIPT_OPTS['logLvl'] >= LAST_LOG_LVL)); then
		local type=${LOG_NAMES[$LAST_LOG_LVL]}
		((SCRIPT_OPTS['color'] > 0)) && type=$(ansi "$type" "${type^^}" fg) || type=${type^^}
		echo "$type$(print ": $ACTION$2")" 1>&2
	fi
	if ((SSS_OPTS['exitLogLvl'] >= LAST_LOG_LVL)); then
		[[ $ACTION == ${SSS_OPTS['exitFn']} ]] && exit -1 || "${SSS_OPTS['exitFn']}" $LAST_LOG_LVL
	fi
}

# Supports simple redirection ... '>'/'>>' 'path'
exec() {
	((SCRIPT_OPTS['logLvl'] > 3)) && log Verbose " \$> $*"
	((SCRIPT_OPTS['dryRun'] > 0)) && return
	if [[ ${*:0-2:1} == \>* ]]; then
		if [[ ${*:0-2:1} == \>\> ]]; then
			"${@:1:$#-2}" >>"${!#}"
		else
			"${@:1:$#-2}" >"${!#}"
		fi
	else
		"$@"
	fi
}

main() {
	call define --config

	if ((SCRIPT_OPTS['cli'] > 0)); then
		while (($#)); do
			parseAction "$@"
			shift $?
		done
		((SCRIPT_OPTS['tui'] > 0)) || quit
		SCRIPT_OPTS[cli]=0
	fi

	SCRIPT_OPTS[argPicker]=1
	local _esc
	while :; do
		if ((SCRIPT_OPTS['optArgPicker'])); then
			read -rp "Choose $(ansi italic action noitalic delim \( oper + param opts delim \): fg) " line
		else
			read -rp "Choose $(ansi italic action noitalic delim : fg) " -n 1 line
			echo
		fi
		if [[ $line == $'\004' ]]; then
			line=q
		elif [[ $line == $'\E' ]]; then
			_esc=1
			continue
		elif [[ $_esc && $line == O ]]; then # arrow movement
			read -rn 1
			continue
		fi
		_esc=

		if [[ $line == [-+]* ]]; then
			parseAction $line
		elif [[ ${line%% *} == ? ]]; then
			parseAction -$line
		else
			local _prefix=
			while [[ ! $_prefix =~ ^${SSS_OPTS['optPrefix']}$ ]]; do
				_prefix+=-
			done
			parseAction $_prefix$line
		fi
		LAST_LOG_LVL=100
	done
}

true=1 false=-1
# set all required variables and call action
parseAction() {
	declare -i argc=$#

	local ACTION= actionArg= actionArgFromEnd=
	log Trace "parsing $*"
	if [[ $1 =~ ^(${SSS_OPTS['optPrefix']})([^-][^=]+)(=.*)?$ ]] && { # full action name
		actionArg=${BASH_REMATCH[3]:1}
		ACTION=$(
			isAction() { [[ ${ACTION_INFO["$1"]} ]]; }
			detectCase "${BASH_REMATCH[2]}" isAction
		)
	} || {
		[[ $1 =~ ^-([^-])(.*)$ ]] && { # short action
			ACTION=${ACTION_INFO["${1:1:1}"]} actionArg=${BASH_REMATCH[2]:+-${BASH_REMATCH[2]}}
		} && [[ $ACTION ]]
	}; then # action recognized
		if [[ $actionArg ]]; then
			declare -i actionArgFromEnd=$#
			set -- "$actionArg" "${@:2}"
		else
			shift
		fi
	else
		ACTION=${SSS_OPTS['defAction']}
	fi
	unset actionArg

	declare -n sigs=${ACTION}Params
	declare -i sigN=${#sigs[@]}
	((sigN % 4)) && log Fatal "Params definition is missing $((4 - sigN % 4)) fields!"
	local i=-4 posArg= # not `declare -i` to keep unset values as ""

	# distinguish options and args
	declare -A opts=()  # opt names â†’ param map idx
	declare -Ai args=() # idx â†’ usage cnt
	while (((i += 4) < sigN)); do
		local sign=${sigs[i + 1]}
		((${#sign} == 2)) || log Fatal "Params[$((i + 1))] should contain signature, but has '$sign'!"
		[[ $sign != '$'? || ${SSS_OPTS['argAsLongOpt']} -gt 0 ]] && opts["${sigs[$i]}"]="$i"
		[[ $sign != [_$]? ]] && opts["${sign::1}"]=$i # '_'=no short, '$'=arg
		[[ $sign == ?[+!] || $sign == '$'? ]] && posArg=${posArg:-$i} args[$i]=0
	done
	declare -i posArg="${posArg:-$sigN}"
	declare -i firstArg=posArg

	declare -n builder=${ACTION}Builder
	[[ ${builder[*]+ok} ]] || declare -A ${ACTION}Builder # ensure we don't index a null

	declare -n cfg=${ACTION}Config # load config for this action
	set -- "${cfg[@]}" "$@"
	declare +n cfg
	unset cfg optChain arg

	while [[ ${1+y} || $optChain ]]; do # get options and args
		log Trace " parsing ${optChain:+${optChain}[-${#arg}] }'$1'"
		if [[ $optChain ]]; then # processing previously found shortopt chain
			i=${opts["${arg::1}"]}
			if [[ -z $i ]]; then
				log Error " - Invalid option '${arg::1}' in chunk '$optChain'"
				return
			fi

			if ((${#arg} > 1)); then
				arg=${arg:1}
			else # reached last option in chain
				unset arg optChain
			fi
		else # try to parse cli arg as an option
			if [[ $1 == -- && ${#opts[@]} -gt 0 && $ACTION != unknown ]]; then
				shift
				opts=() # only args will be found
				continue
			fi

			local i='' optCnt=+ tmpArr=
			if [[ $# -ne $actionArgFromEnd &&
				$1 =~ ^(${SSS_OPTS['optPrefix']})(no-)?([^- ][^= ]+)(=.*)?$ ]] && {
				tmpArr=("${BASH_REMATCH[@]}")
				i=$( # index for full option name
					isOpt() { [[ ${opts["$1"]} ]]; }
					detectCase "${tmpArr[3]}" isOpt
				) && {
					i=${opts["$i"]}
					[[ ${tmpArr[2]} ]] && optCnt=- # `no-` means toggle off
					[[ ! ${tmpArr[4]} ]] || local arg=${tmpArr[4]:1}
				}
			} || { # short option -o(Val)?
				[[ $1 =~ ^[+-]([^-])(.+)?$ ]] && i=${opts["${BASH_REMATCH[1]}"]} && [[ $i ]] && {
					[[ $1 == +* ]] && optCnt=- # `+o` means toggle off
					[[ ! ${BASH_REMATCH[2]} ]] || local arg=${BASH_REMATCH[2]} optChain=$1
				}
			}; then # option recognized
				shift
			fi
		fi

		if [[ $i ]]; then # set option / named parameter
			local varName=${sigs[$i]//-/_} reg=${sigs[i + 2]}
			if [[ $reg ]]; then # requires arg
				if [[ $optCnt == - ]]; then
					unset "$varName" # `+o` resets the option value - for config override
					[[ ${args[$i]} ]] && args[$i]=-1
				elif [[ ${arg+y} || ${1+y} ]] && argMatch "${arg-$1}"; then
					if [[ ${sigs[i + 1]} == ?[?!] ]]; then
						declare "$varName=${arg-$1}"
						log Debug ".$varName = '${!varName}'"
					else
						declare _varName=$varName
						declare -a "$varName" # necessary to override values declared higher in the stack
						declare -n varName
						log Debug ".${_varName}[${#varName[@]}] = '${arg-$1}'"
						varName+=("${arg-$1}")
						declare +n varName
					fi

					if [[ ${arg+y} ]]; then
						unset arg optChain # arg is last in optChain â†’ optChain has been fully parsed
					else
						shift
					fi
				elif [[ (! ${arg+y} || $optChain) && ${SSS_OPTS['onNoArg']} -ge 0 ]] && argMatch ''; then
					if argMatch 3; then
						declare -i "$varName+=1" # counter
						log Debug ".$varName = ${!varName}"
					else
						declare -i "$varName=1" # boolean
						log Debug ".$varName = true"
					fi
				elif [[ (! ${arg+y} || ($optChain && ${opts["${arg::1}"]})) &&
					${SSS_OPTS['onNoArg']} -gt 0 && ${SCRIPT_OPTS['optArgPicker']} -gt 0 ]] && {

					[[ ${sigs[i + 1]} == ?[+*] ]] && declare -a "$varName" || local "$varName"

					"${builder["$varName"]:=$(determinePicker "$reg")}" "${sigs[@]:i:4}" || {
						((${SCRIPT_OPTS['ignoreFailedPicker']} > 0)) && i=-1
					}
				}; then
					if ((i < 0)); then
						log Debug ".$varName - ${builder["$varName"]} failed, skipping option"
					else
						log Debug ".$varName <${builder["$varName"]}>= '${!varName}'"
					fi
				else # bad arg, or picker failed
					[[ ! $optChain ]] &&
						log Error ".$varName - Invalid argument '${arg-$1}'" ||
						log Error ".$varName - Invalid argument '${arg-$1}' at chunk '$optChain'"
					return
				fi
			elif [[ ! $optChain && ($arg == false || $arg == true) ]]; then
				declare -i "$varName=$arg"
				log Debug ".$varName = $arg"
				unset arg
			elif [[ $optChain || ! ${arg+y} ]]; then
				declare -i "$varName+=${optCnt}1"
				log Debug ".$varName = ${!varName}"
			else
				log Error ".$varName - Unexpected argument '$arg'"
				return
			fi

			[[ ${args[$i]} ]] && args[$i]+=1 # required option
			[[ $optChain ]] && continue
		else # set arg
			if ((posArg >= sigN)); then
				if ((USE_ALL_ARGS)); then
					log Error " - Too many arguments: $*"
					return
				else
					break # NOTE: this is where the loop ends successfully
				fi
			fi
			# remove '-' from arg incorrectly perceived as an option in a shortopt chain
			[[ $# -eq $actionArgFromEnd ]] && set -- "${1#-}" "${@:2}"

			while ((posArg < sigN)); do
				local varName=${sigs[$posArg]//-/_} sign=${sigs[posArg + 1]} reg=${sigs[posArg + 2]}
				if [[ $sign == '$'? ]] && argMatch "$1"; then
					args[$posArg]+=1              # update before posArg changes
					if [[ $sign == ?[+*] ]]; then # param is a list
						declare _varName=$varName
						declare -a "$varName"
						declare -n varName
						log Debug "\$${_varName}[${#varName[@]}] = '$1'"
						varName+=("$1")
						declare +n varName
					else # single argument expected
						declare "$varName=$1"
						posArg+=4
						log Debug "\$$varName = '${!varName}'"
					fi
					local argUsed=1
					shift
					break # continue in parsing cli
				else
					if [[ $sign == '$'? ]]; then
						if [[ $sign == ?[?*] || ${args[$posArg]} -gt 0 ]]; then
							log Trace ".$varName != '$1'"
						else
							log Error ".$varName != '$1', but is next in order"
						fi
					fi
					posArg+=4 # given value doesn't match â†’ try next arg
				fi
			done

			if (($# == actionArgFromEnd && !argUsed)); then
				log Error " - Invalid argument '$1'"
				return 1
			fi
			unset argUsed
		fi

		[[ $1 ]] || break
		(($# < actionArgFromEnd)) && break # stop after chain started by action (not option)
	done

	i=$firstArg-4
	unset actionArgFromEnd posArg firstArg opts tmpArr _varName

	while (((i += 4) < sigN)); do
		local varName=${sigs[i]} sign=${sigs[i + 1]} reg=${sigs[i + 2]}
		((${args[$i]:-1} > 0)) && continue # opts don't have an entry, filled args > 0

		# picker for optional args || arg required
		if [[ ${SCRIPT_OPTS['argPicker']} -gt 0 && $sign == ?[!+] ]]; then
			declare -a "$varName"
			if "${builder["$varName"]:=$(determinePicker "$reg")}" "${sigs[@]:i:4}"; then
				args[$i]+=1
				log Debug "\$$varName <${builder["$varName"]}>= '${!varName}'"
			fi
		fi

		if [[ ${args[$i]} == 0 && $sign == ?[+!] ]]; then
			log Error " - Missing argument for '$varName'"
			return
		fi
	done

	declare +n builder sigs
	unset sigs i sigN args builder varName sign reg

	# ensure valid state
	if [[ $ACTION == "${SSS_OPTS['defAction']}" && $# -gt 0 && ${SSS_OPTS['defActionLast']} ]]; then
		log Error " - Default action must use all args, but some were left: $*"
	fi

	log Trace ' >>' && "$ACTION" && log Trace ' finished!' || log Warn ' failed!'
	return $((argc - $#))
}

call() { # for script usage - calling actions like itself with cli, without external process
	USE_ALL_ARGS=1 parseAction "$@"
	(($? == $# && LAST_LOG_LVL > 3))
}

declare -A REGEX=(
	[var]='[A-Za-z_][0-9A-Za-z_]*' [dashvar]='[A-Za-z_][0-9A-Za-z_-]*'
	[const]='[A-Z_][0-9A-Z_]*' [domain]='[a-z0-9]+\.[0-9a-z.]+'
)
REGEX[email]="${REGEX['var']}@${REGEX['domain']}"
REGEX[str]="\"[^\"]*\"|'([^']|'[A-Za-z])*'|\`[^\`]*\`"

#######################################
# Test ^(RE)$ or custom pattern like $<k><RE> - <k>: test kind, <RE> tests the input text
# $<b>: <b>: bash condexpr operator, match against RE$
# $F: ensure a file can be created at given path, RE$
# $^: mime type ^RE, follows symlinks
# $|: fallback ^(RE)$, must be last in the pattern
# Globals:
#   reg: required format of the argument - described custom pattern
# Arguments:
#   tested: input argument to be tested against the pattern
#######################################
argMatch() {
	local tested=$1
	if [[ $reg == '$'* ]]; then # file requirements
		local ptn reg=$reg kind

		if [[ $reg == *'$|'* ]]; then
			ptn=${reg#*'$|'}
			log Trace " '$tested' =? $ptn"
			[[ $tested =~ ^($ptn)$ ]] && return 0 # one of special values after '$|'
			reg=${reg::-2-${#ptn}}
		fi

		if ! [[ $tested =~ ^[^+-][^=]*$ ]]; then
			log Debug ": rejected '$tested' as a filename"
			return 1
		fi

		while [[ $reg ]]; do
			ptn=${reg:2} kind=${reg:1:1}
			ptn=${ptn%%'$'*}
			log Trace " '$tested' =? \$$kind$ptn"

			if [[ $kind == '^' ]]; then
				[[ $(file -Lb --mime-type "$tested") =~ ^$ptn ]] && return 0
			else
				[[ ${tested,,} =~ $ptn$ ]] && if [[ $kind == F ]]; then
					[[ ! -d $tested ]] && return 0
				else
					eval [[ -$kind '$tested' ]] && return 0
				fi
			fi

			reg=${reg:2+${#ptn}}
		done

		return 1
	else # normal regex
		[[ $tested =~ ^($reg)$ ]]
	fi
}

#######################################
# Print help about specified parameter from given action.
# Arguments:
#   action: string
#   matcher: boolean show regex used for matching args
#   paramIdx?: integer
#######################################
paramHelp() {
	local action=$1 matcher=$2 fmt
	declare -n name=${action}Params
	[[ $3 ]] && declare -i i="$3*4" end=i+4 || declare -i i=0 end=${#name[@]}
	declare -a sig desc
	declare -i maxLen="$ALIGNER"
	i+=-4
	while (((i += 4) < end)); do
		local varName=$(caseToArg "${name[$i]}")
		local sign=${name[i + 1]} regex=${name[i + 2]} help=${name[i + 3]}
		if [[ $sign == [^$][?*!+] ]]; then # option/non-positional arg
			if [[ $sign == _? ]]; then
				varName=--$varName
			else
				# varName="-${sign::1}, --$varName"
				local _s=${sign::1}
				[[ $varName == [A-Z]* ]] && _s=${_s^} || _s=${_s,}
				if [[ $varName =~ ^(.*[_-])?$_s ]]; then
					varName="--${BASH_REMATCH[1]}[${sign::1}]${varName:${#BASH_REMATCH[0]}}"
				else
					varName="--[${sign::1}]$varName"
				fi
			fi
			sign=${sign:1}
		else
			varName=\$$varName
			sign=${sign:1} # positional param
		fi

		((SCRIPT_OPTS[color] > 0)) && sign+=$(ansi nobold)
		if [[ $regex ]]; then
			((matcher <= 0)) && sign+=' <>' || sign+=" <$regex>"
		fi

		sign="$varName$sign"
		sig+=("$sign")
		((maxLen < ${#sign})) && maxLen=${#sign}

		desc+=("$help")
	done
	((SCRIPT_OPTS[color] > 0)) && fmt='\033[1m%-*s  %s' || fmt='%-*s  %s'
	i=-1
	while ((++i < ${#sig[@]})); do
		print "    $(printf "$fmt" "$maxLen" "${sig[$i]}" "${desc[$i]}")"
	done
}

actionInfo help 'display this help'
ACTION_INFO['?']=help
helpParams=(
	legend 'l?' '' 'Enable legend for param notation'
	matcher 'm?' '' 'Enable regex matching argument'
	params 'p?' '' 'Toggle params=opt+arg display (default=true for lower action count)'
	actions '$*' '.+' 'Display help for (default=all)')
declare -A helpBuilder=([actions]=pickHelpAction)
pickHelpAction() {
	declare -n arr="$1"
	arr=("$(printf '%s\n' "${ACTION_ORDER[@]}" | fzf -m --prompt="$4: ")")
}
help() {
	if [[ ! $actions ]]; then
		declare -n actions=ACTION_ORDER
		local default=true
		((SCRIPT_OPTS[cli] > 0)) && print "${SSS_OPTS[about]}"
	fi
	((legend > 0)) && print 'Legend:
  action: [a]ction
    - short name: in brackets if exists
      - in CLI prefix with `-`, not necessary in TUI
      - value immediately after or as the next arg (-aVal / -a val)
    - full name usage: better option separation from next action
      - prefix must match /'"${SSS_OPTS[optPrefix]}"'/
      - value given with `=` or as the next arg (--act=val / --act val)
    - orderless (aside of repeated uses)
  options/named params: [o]ption + suffix + type suffix (or [a]option or []option)
    - short names can be chained with argument as last: `-aoOarg` (also `+aoOarg`)
		- `+` sets option to false / adds negative value (`+lll` â†’ logLvl+=-3)
    - suffix:
      - `!`,`+`: required Ã— `?`,`*`: optional
      - `?`,`!`: single use Ã— `*`,`+`: multiple uses/values accepted
    - no `<>` â†’ toggles: `-o`/`--option` â†’ +1, `+o`/`--no-option` â†’ -1
    - type suffix `<>`: for opts requiring an arg
      - can act as a toggle if accepts '' as an arg
  positional params/arguments: name + suffix
    - order matters, next param is set when current arg does not match the previous one
    - suffix: `?`,`!`: single arg; `*`,`+`: list of values
    - use `--` to separate opts from args (no opts will be accepted after that)
	arg matcher notation:
    - /regex/ - simple input regex
    - $k<RE> - <RE> tests the input text, $k/kind:
      - $<b>: bash condexpr operator, ends with RE
      - $F: ensure file can exist at user input, ends with RE
      - $^: existing input file mime type starts with RE
      - $|: fallback simple input regex'

	[[ $default && ${#actions[@]} -gt 9 ]]
	declare -i params="${params:-$?}"

	if [[ $default ]]; then
		print 'Actions: (more info available per action)'
	else
		((${#actions[@]} > 1)) && print 'Actions:' || print 'Action:'
	fi
	local act fmt
	((SCRIPT_OPTS[color] > 0)) && fmt='\033[1;4m%-*s  \033[0;4m%s\033[m' || fmt='%-*s  %s'
	for act in "${actions[@]}"; do
		if [[ ${act#-} == ? ]]; then
			act=${ACTION_INFO["${act#-}"]:-$act} # keep the original to have valid `desc` index
		elif [[ $act =~ ^-*([^-][^=]*)$ ]]; then
			act=$(
				isAction() { [[ ${ACTION_INFO["$1"]} ]]; }
				detectCase "$act" isAction || echo "$act"
			)
		fi

		local desc=${ACTION_INFO["$act"]}
		if [[ $desc ]]; then
			printf "  $fmt\n" "$ALIGNER" "${desc%% *}" "$(print "${desc#* }")"
			# enabled params or always write complete info about help options
			[[ $params -le 0 && $act != help ]] || paramHelp "$act" "$matcher"
		else
			print "  No help for unknown action '${_act:-$act}'"
		fi
	done
}

actionInfo quit 'exit the tui' # also called when exiting the cli
quit() {
	"${SSS_OPTS['exitFn']}" 0 # override this for commit-before-exit
}

unknownParams=(argument '$+' '.*' 'consumes all remaining args to end execution')
unknown() {
	log Error " action '$argument'!"
}

# Chooses the fallback picker based on $1=regex/argMatch pattern
declare -A PICKER_FOR_REGEX
determinePicker() {
	case "$1" in
		'$d'*'$f'*) echo pickFilesOrDir ;;
		'$d'*) echo pickDir ;;
		'$f'*) echo pickFile ;;
		*) echo ${PICKER_FOR_REGEX["${1:-'$'}"]:-pickValue} ;;
	esac
}

pickValue() {
	declare -n _dst="$1"
	while :; do
		local _pick=
		while [[ ! $_pick =~ ^$3$ ]]; do
			if ((SCRIPT_OPTS['guiPicker'] > 0)); then
				_pick=$(rofi -dmenu -p "${_pick:+Argument has to match /$3/! }$4")
			else
				[[ $_pick ]] && print "Argument has to match /$3/"
				read -rp "$(print "$4: ")" _pick
			fi
			[[ $_pick ]] || break
		done

		if [[ $2 == ?[+*] ]]; then
			[[ $_pick ]] || break
			_dst+=("$_pick")
		else
			_dst="$_pick"
			break
		fi
	done
	[[ $_dst ]]
}

RANGER_CMD=(ranger --cmd='set viewmode multipane')

pickDir() {
	local tmp="$(mktemp)"
	"${RANGER_CMD[@]}" --choosedir="$tmp"
	if [[ -e $tmp ]]; then
		declare -n _choice="$1"
		_choice="$(cat "$tmp")"
	fi
	rm "$tmp"
	[[ -d ${!1} ]]
}

pickFile() {
	local tmp="$(mktemp)"
	"${RANGER_CMD[@]}" --choosefile"$([[ $2 == ?[+*] ]] && echo s)=$tmp"
	if [[ -e $tmp ]]; then
		mapfile -t "$1" <"$tmp"
	fi
	rm "$tmp"
	[[ -f ${!1} ]]
}

pickFilesOrDir() {
	((SCRIPT_OPTS['guiPicker'] > 0)) &&
		local _cmd=(rofi -dmenu) ||
		local _cmd=(fzf --prompt "$4: " --preview 'ls {}')
	if [[ $2 == ?[+*] ]]; then
		((SCRIPT_OPTS['guiPicker'] > 0)) && _cmd+=(-multi-select) || _cmd+=(-m)
	fi
	declare -n selected="$1"
	local toView=(.) _ng=("$(shopt -p nullglob)")
	shopt -s nullglob
	while :; do
		local f
		readarray -t _pick < <({
			echo '..'
			for f in "${toView[@]}"; do
				f=("$f"/*)
				printf '%s\n' "${f[@]}"
			done
		} | "${_cmd[@]}")

		if [[ -z $_pick ]]; then
			[[ -d $toView && $toView != '.' ]] && selected="$toView"
			break
		fi
		toView=()
		for f in "${_pick[@]}"; do
			if [[ -f $f ]]; then
				selected+=("$f")
			else
				toView+=("$f")
			fi
		done
		[[ ($selected && $2 != ?[+*]) || -z $toView ]] && break
	done
	[[ ${_ng[1]} == -s ]] || shopt -u nullglob
	[[ -e ${!1} ]]
}

if [[ $0 == *sss ]]; then
	SSS_OPTS[about]='SSS - A script simplifying scripting
Provides automatized param handling, arg/opt parsing+autodoc.
Usage:
  1. Change $SSS_OPTS to suit your script.
  2. Source this script: `. sss`
  3. Register your actions
     actionInfo <fName> <shortName>? <nameHelpFormat>? <fDescription>
  4. Declare action opts/args, see `help` for meanings
     <fName>Params=(<varName> <shortOpt+countSuffix> <argMatch> <description>)
     toggleable arg opts should be always default=false
	5. Declare a mapping of picker functions for args if defaults are insufficient
     declare -A <fName>Builder=([<argName>]=<picker/selector fName>)
  6. Picker gets full arg quaternion, saves selection to $1/argName
  7. Write your function.
  8?. for execution after configuration overwrite SSS_OPTS[exitFn]
  9. Call `main "$@"` at the end of your script; set defAction for setup-then-exec use
There are a few predefined pickers and regexes you can use.'
	main "$@"
	# style rules:
	# - quote map indexing to avoid confusion with arrays (where text is expanded as a var)
	# - use `&&/|| {...}` only for success value uses
	# - use multiple `&&`, `||` in one cmd only when declaring variables
	# - avoid `&&` where `;`/`\n` can be used when executing consecutive commands
	# - use `[[...]] &&/||` to match the main intended path (â†’ `||` shows it's not the main intent)
fi
